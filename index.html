<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Multi-Cloud Storage Optimizer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Orbitron for titles, Roboto Mono for data -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&family=Roboto+Mono:wght=400;700&display=swap" rel="stylesheet">
    <!-- Chart.js for the forecast graph -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

    <style>
        :root {
            --bg-color: #0d0d12;
            --card-color: #1e1e2c;
            --text-color: #e0f7fa;
            --accent-color: #00e5ff; /* Neon Cyan */
            --highlight-color: #82b1ff; /* Light blue glow */
            --error-color: #ff3d00; /* Neon red */
            --success-color: #69f0ae; /* Neon green */
            
            /* NEW CHART COLORS for Professional & Futuristic Look */
            --chart-actual-color: #00e5ff; /* Bright Cyan (Hex code) */
            --chart-predicted-color: #c084fc; /* Vibrant Violet (Hex code) */
            
            --glow-filter: 0 0 8px var(--accent-color);
        }

        body {
            font-family: 'Roboto Mono', monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
        }

        /* Utility classes for the futuristic/neon look */
        .card-futuristic {
            background-color: var(--card-color);
            border: 1px solid #333;
            box-shadow: var(--glow-filter);
        }
        .header-futuristic {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent-color);
            text-shadow: 0 0 5px rgba(0, 229, 255, 0.5);
        }
        .input-futuristic:focus {
            border-color: var(--accent-color);
            outline: none;
            box-shadow: 0 0 5px var(--accent-color);
        }

        /* --- Custom Styles for Graph Nodes (Dependency Modal) --- */
        .node {
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .node:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 0 20px rgba(0, 229, 255, 0.4);
        }
        .graph-line {
            stroke: #00e5ff; /* Neon Cyan */
            stroke-width: 2;
            transition: stroke-width 0.3s;
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #82b1ff; /* highlight-color */
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background-color: #1a1a24;
        }

        /* Metrics boxes specific styling */
        .metric-box {
            border: 1px solid var(--accent-color);
            box-shadow: 0 0 10px rgba(0, 229, 255, 0.2);
        }
        .metric-value {
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 5px rgba(105, 240, 174, 0.5);
        }

        /* Toggle Switch Styling */
        .toggle-switch input[type="radio"] {
            display: none;
        }
        .toggle-label {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-radius: 9999px; /* Fully rounded */
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 0.875rem; /* text-sm */
            background-color: #2a2a38;
            color: #9ca3af; /* Gray text */
            border: 1px solid #374151;
        }
        .toggle-switch input[type="radio"]:checked + .toggle-label {
            background-color: var(--accent-color);
            color: var(--bg-color); /* Dark text on neon */
            box-shadow: 0 0 10px rgba(0, 229, 255, 0.6);
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <!-- Modal for Dependency Graph -->
    <div id="dependencyModal" class="fixed inset-0 bg-gray-900 bg-opacity-90 z-50 hidden flex items-center justify-center p-4">
        <div class="card-futuristic bg-indigo-900/10 w-full max-w-5xl max-h-[95vh] rounded-xl shadow-2xl flex flex-col border-indigo-500/50">
            <div class="p-6 border-b border-indigo-500/50 flex justify-between items-center bg-[#181824]">
                <h2 class="text-2xl font-bold header-futuristic">Graph-Based Dependencies</h2>
                <button id="closeDependencyModalBtn" class="text-gray-400 hover:text-white transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>

            <div class="p-6 flex-grow overflow-y-auto custom-scrollbar">
                <p class="text-sm text-gray-400 mb-4">
                    The AI models workload topology to ensure cross-cloud connections (like AWS to Azure DB) meet latency and security constraints before making tiering decisions.
                </p>

                <!-- Dependency Graph (Simplified SVG/Grid Layout) -->
                <div class="relative w-full h-[500px] bg-[#1a1a24] rounded-lg p-6 flex flex-col justify-between items-center border border-indigo-700/50">

                    <!-- Center/Core Node -->
                    <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">
                        <div class="node bg-indigo-600 text-white p-4 rounded-full w-28 h-28 flex items-center justify-center text-center font-bold shadow-lg ring-4 ring-indigo-300">
                            AI Optimizer Core
                        </div>
                    </div>

                    <!-- Cloud Service Nodes -->
                    <div class="flex justify-around w-full mt-4">
                        <div class="node w-32 h-20 bg-[#2a2a38] border border-gray-700 shadow-md rounded-lg flex flex-col items-center justify-center p-2 text-center text-sm font-medium text-gray-200 hover:border-indigo-500">
                            <span class="text-green-400 font-bold">GCP</span>
                            Data Lake (Archive)
                        </div>
                        <div class="node w-32 h-20 bg-[#2a2a38] border border-gray-700 shadow-md rounded-lg flex flex-col items-center justify-center p-2 text-center text-sm font-medium text-gray-200 hover:border-indigo-500">
                            <span class="text-yellow-400 font-bold">AWS</span>
                            Edge Inference
                        </div>
                    </div>

                    <!-- Bottom Services Nodes -->
                    <div class="flex justify-around w-full mb-4">
                        <div class="node w-32 h-20 bg-[#2a2a38] border border-gray-700 shadow-md rounded-lg flex flex-col items-center justify-center p-2 text-center text-sm font-medium text-gray-200 hover:border-indigo-500">
                            <span class="text-blue-400 font-bold">AZURE</span>
                            Policy DB
                        </div>
                        <div class="node w-32 h-20 bg-[#2a2a38] border border-gray-700 shadow-md rounded-lg flex flex-col items-center justify-center p-2 text-center text-sm font-medium text-gray-200 hover:border-indigo-500">
                            K8s Operator
                            (Workload)
                        </div>
                    </div>

                    <!-- Lines (Simulated Connections using SVG) -->
                    <svg class="absolute inset-0 w-full h-full pointer-events-none">
                        <!-- Line from GCP Node (Top Left) to Center Core -->
                        <line x1="20%" y1="20%" x2="50%" y2="50%" class="graph-line" />
                        <!-- Line from AWS Node (Top Right) to Center Core -->
                        <line x1="80%" y1="20%" x2="50%" y2="50%" class="graph-line" />
                        <!-- Line from Azure Node (Bottom Left) to Center Core -->
                        <line x1="20%" y1="80%" x2="50%" y2="50%" class="graph-line" />
                        <!-- Line from K8s Node (Bottom Right) to Center Core -->
                        <line x1="80%" y1="80%" x2="50%" y2="50%" class="graph-line" />
                        <!-- Line between AWS (Top Right) and K8s (Bottom Right) -->
                        <line x1="80%" y1="20%" x2="80%" y2="80%" stroke="#facc15" stroke-width="2" stroke-dasharray="4 2" />
                    </svg>
                </div>
            </div>

            <div class="p-4 border-t border-indigo-500/50 bg-[#181824] flex justify-end">
                <button onclick="closeDependencyModal()"
                    class="px-4 py-2 bg-gray-700 text-gray-200 font-medium rounded-lg hover:bg-gray-600 transition">
                    Close Diagram
                </button>
            </div>
        </div>
    </div>
    
    <!-- Modal for Provisioning Simulation -->
    <div id="provisionModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 hidden flex items-center justify-center p-4">
        <div class="bg-indigo-900/10 card-futuristic p-10 rounded-xl text-center border-green-500/50 shadow-green-500/40">
            <h3 class="text-2xl font-bold text-success-color mb-4" style="color: var(--success-color); font-family: 'Orbitron', sans-serif;">&#9889; Provisioning Simulation Complete &#9889;</h3>
            <p id="modal-text" class="text-gray-300 mb-6">IaC Automation successful. Storage solution provisioned to the optimal tier.</p>
            <button onclick="document.getElementById('provisionModal').style.display='none'" class="px-6 py-2 bg-green-500 text-gray-900 font-semibold rounded-lg hover:bg-green-400 transition">Close Terminal</button>
        </div>
    </div>

    <!-- Main Content Area -->
    <header class="w-full mb-8">
        <div class="logo header-futuristic text-4xl font-black text-center pt-4 pb-2">AI-Driven Storage Optimization</div>
        <p class="text-center text-gray-400 text-sm">Unified Cost, Latency, and Compliance Engine</p>
    </header>

    <main class="max-w-6xl mx-auto">
        
        <!-- Input Section -->
        <section id="input" class="card-futuristic p-6 md:p-8 rounded-xl mb-8">
            <h2 class="text-xl md:text-2xl mb-6 header-futuristic border-b border-indigo-700 pb-3">ðŸ”® Predictive Input & Policy Engine</h2>
            <form id="optimizerForm">
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                    <div class="form-group">
                        <label for="dataSize" class="block mb-2 text-highlight-color font-bold" style="color: var(--highlight-color);">Data Volume (TB)</label>
                        <input type="number" id="dataSize" value="100" min="1" required class="w-full p-3 rounded-lg bg-[#2a2a38] border border-[#444] text-text-color input-futuristic">
                    </div>

                    <div class="form-group">
                        <label for="accessFrequency" class="block mb-2 text-highlight-color font-bold" style="color: var(--highlight-color);">Access Frequency (Reads/Month, in Millions)</label>
                        <input type="number" id="accessFrequency" value="50" min="1" required class="w-full p-3 rounded-lg bg-[#2a2a38] border border-[#444] text-text-color input-futuristic">
                    </div>

                    <div class="form-group">
                        <label for="forecastWindow" class="block mb-2 text-highlight-color font-bold" style="color: var(--highlight-color);">Forecasting Horizon (Months)</label>
                        <input type="number" id="forecastWindow" value="24" min="1" required class="w-full p-3 rounded-lg bg-[#2a2a38] border border-[#444] text-text-color input-futuristic">
                    </div>

                    <div class="form-group">
                        <label for="compliance" class="block mb-2 text-highlight-color font-bold" style="color: var(--highlight-color);">Compliance Policy (e.g., GDPR, HIPAA)</label>
                        <input type="text" id="compliance" value="GDPR" placeholder="e.g., GDPR, HIPAA" required class="w-full p-3 rounded-lg bg-[#2a2a38] border border-[#444] text-text-color input-futuristic">
                    </div>

                    <div class="form-group">
                        <label for="budget" class="block mb-2 text-highlight-color font-bold" style="color: var(--highlight-color);">Max Monthly Budget ($)</label>
                        <input type="number" id="budget" value="5000" min="100" required class="w-full p-3 rounded-lg bg-[#2a2a38] border border-[#444] text-text-color input-futuristic">
                    </div>

                    <div class="form-group flex items-center pt-8">
                        <input type="checkbox" id="injectAnomaly" class="w-5 h-5 mr-3 rounded text-error-color focus:ring-error-color bg-[#2a2a38] border border-[#444]">
                        <label for="injectAnomaly" class="text-error-color font-bold">Simulate Access Anomaly Detection?</label>
                    </div>
                </div>

                <button type="submit" class="w-full mt-8 px-6 py-3 bg-accent-color text-bg-color font-bold rounded-lg shadow-lg hover:bg-highlight-color transition submit-btn" style="box-shadow: 0 0 15px var(--accent-color);">
                    Run AI Optimization Loop â†’
                </button>
            </form>
        </section>

        <!-- Output Section (Made visible by default) -->
        <section id="output" class="card-futuristic p-6 md:p-8 rounded-xl">
            <h2 class="text-xl md:text-2xl mb-6 header-futuristic border-b border-indigo-700 pb-3"><span style="color: var(--success-color);">&#10003;</span> Optimization Recommendation</h2>

            <!-- Constraint Violation Alert -->
            <div id="violationAlert" class="p-4 rounded-lg mb-6 hidden border-2 border-error-color bg-[#2c1a1a]" style="box-shadow: 0 0 10px var(--error-color);">
                <p id="violationMessage" class="text-lg font-bold text-error-color">&#10060; CRITICAL CONSTRAINT VIOLATION</p>
                <p id="violationSolution" class="text-sm mt-2 text-gray-300">Loading reason and solution...</p>
            </div>

            <!-- Anomaly Alert -->
            <div id="anomalyAlert" class="p-4 rounded-lg mb-6 hidden border-2 border-error-color bg-yellow-900/30" style="box-shadow: 0 0 10px var(--error-color);">
                <p class="text-sm font-bold text-yellow-300">&#9888; ANOMALY DETECTED:</p>
                <p class="text-sm text-gray-300">Predicted access spike in the next <span id="alert-months"></span> months. Recommendation has been proactively shifted to a **Warmer Tier** to prevent high egress costs and latency penalties.</p>
            </div>

            <!-- Key Metrics -->
            <div id="resultContainer" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
                <div class="metric-box bg-[#2a2a38] p-4 rounded-lg text-center">
                    <h3 class="text-sm text-highlight-color uppercase font-bold mb-1">Optimal Provider/Tier</h3>
                    <p id="resultProvider" class="text-2xl font-bold text-success-color metric-value">Run Optimizer</p>
                </div>
                <div class="metric-box bg-[#2a2a38] p-4 rounded-lg text-center">
                    <h3 class="text-sm text-highlight-color uppercase font-bold mb-1">Projected Monthly Savings</h3>
                    <p id="resultSavings" class="text-2xl font-bold text-success-color metric-value">0%</p>
                </div>
                <div class="metric-box bg-[#2a2a38] p-4 rounded-lg text-center">
                    <h3 class="text-sm text-highlight-color uppercase font-bold mb-1">Projected Latency Reduction</h3>
                    <p id="resultLatency" class="text-2xl font-bold text-success-color metric-value">~0%</p>
                </div>
                <div class="metric-box bg-[#2a2a38] p-4 rounded-lg text-center">
                    <h3 class="text-sm text-highlight-color uppercase font-bold mb-1">Automation Level</h3>
                    <p id="resultAutomation" class="text-2xl font-bold text-success-color metric-value">&ge; 95%</p>
                </div>
            </div>

            <!-- Cost Breakdown Visualization (Bar Chart) -->
            <div class="mb-8 p-4 border border-indigo-700/50 rounded-lg bg-[#1a1a24]">
                <h3 class="text-lg font-bold text-highlight-color mb-4 header-futuristic">Cost Allocation Breakdown (Optimized vs. Baseline)</h3>
                <div class="flex h-40 gap-4 justify-around items-end" id="costBreakdownChart">
                    <!-- Bars are dynamically inserted here -->
                </div>
            </div>

            <!-- Future Prediction Graph (Chart.js) -->
            <div id="futureGraphContainer" class="mb-8 p-4 border border-indigo-700/50 rounded-lg bg-[#1a1a24]">
                <h3 class="text-lg font-bold text-highlight-color mb-4 header-futuristic">Storage Usage/Cost Forecast: Actual vs. Predicted</h3>
                
                <!-- INTERACTIVE TOGGLE -->
                <div class="flex justify-center mb-6 toggle-switch">
                    <input type="radio" id="toggleUsage" name="graphMode" value="usage" checked onchange="toggleGraphMode(this.value)">
                    <label for="toggleUsage" class="toggle-label mr-2">Data Usage (TB)</label>
                    
                    <input type="radio" id="toggleCost" name="graphMode" value="cost" onchange="toggleGraphMode(this.value)">
                    <label for="toggleCost" class="toggle-label">Projected Cost ($)</label>
                </div>
                
                <div style="height: 350px;">
                    <canvas id="usageChart"></canvas>
                </div>
                
                <div class="flex justify-center gap-6 mt-4 text-xs text-gray-400 border-t border-gray-700 pt-3">
                    <div class="flex items-center"><span class="w-3 h-3 rounded-full mr-2" style="background-color: var(--chart-actual-color);"></span> Actual Historical Data</div>
                    <div class="flex items-center"><span class="w-3 h-3 rounded-full mr-2" style="background-color: var(--chart-predicted-color);"></span> AI Predicted Future Data</div>
                </div>
            </div>

            <!-- Explainable AI (XAI) -->
            <div class="mt-8 pt-4 border-t border-indigo-700/50">
                <h3 class="text-lg font-bold text-highlight-color mb-3 header-futuristic">Transparency & Explanation (XAI)</h3>
                <p id="resultExplanation" class="text-sm text-gray-300">Run the optimization loop above to generate an explainable decision.</p>
            </div>
            
            <!-- Action Buttons -->
            <div class="mt-8 grid grid-cols-1 md:grid-cols-2 gap-4">
                <button id="provisionButton" class="px-6 py-3 bg-green-500 text-bg-color font-bold rounded-lg shadow-lg hover:bg-green-400 transition" style="box-shadow: 0 0 15px var(--success-color);">
                    Simulate Provisioning via Terraform (IaC) â†’
                </button>
                
                <!-- Button to Open Dependency Modal -->
                <button id="openDependencyModalBtn" class="px-6 py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-lg hover:bg-indigo-700 transition" style="box-shadow: 0 0 15px rgba(99, 102, 241, 0.7);">
                    View Dependency Graph
                </button>
            </div>

        </section>
    </main>

    <!-- Full JavaScript Logic -->
    <script>
        let usageChartInstance = null; // To hold the Chart.js instance
        let currentChartData = { usage: [], cost: [], labels: [], dataSize: 0, costPerTB: 0 }; // Store generated data

        // Status Codes for Constraint Handling
        const STATUS = {
            SUCCESS: 'SUCCESS',
            BUDGET_VIOLATION: 'BUDGET_VIOLATION',
            LATENCY_VIOLATION: 'LATENCY_VIOLATION',
            PHYSICAL_VIOLATION: 'PHYSICAL_VIOLATION'
        };

        // --- Helper Functions for Data Simulation ---

        const formatCurrency = (num) => `$${Math.round(num).toLocaleString()}`;
        
        /**
         * Helper function to safely read the value of a CSS variable from the :root.
         * @param {string} varName - The name of the CSS variable (e.g., '--accent-color').
         * @returns {string} The resolved color value (e.g., '#00e5ff').
         */
        function getCssColor(varName) {
            return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        }

        /**
         * Creates a linear gradient for Chart.js using a literal hex color string.
         * @param {object} ctx - The Canvas context object.
         * @param {string} colorHex - The resolved hex color string (e.g., '#00e5ff').
         * @returns {CanvasGradient} The gradient object.
         */
        function createGradient(ctx, colorHex) {
            const gradient = ctx.createLinearGradient(0, 0, 0, 350); // Height of graph
            // Use the hex code directly and append alpha channels (cc=80%, 44=25%, 00=0%)
            gradient.addColorStop(0, `${colorHex}cc`); 
            gradient.addColorStop(0.5, `${colorHex}44`); 
            gradient.addColorStop(1, `${colorHex}00`); 
            return gradient;
        }

        // Data structure for simulated cloud options (Baseline: Standard Hot, Optimized: Tiered)
        const storageOptions = {
            AWS: {
                standard: { tier: 'AWS (S3 Standard)', multiplier: 1.0, costFactor: 0.023, maxLatencyReduction: 0.1, accessCostFactor: 0.02, provider: 'AWS' },
                low_access: { tier: 'AWS (S3 Infrequent Access)', multiplier: 0.65, costFactor: 0.0125, maxLatencyReduction: 0.35, accessCostFactor: 0.012, provider: 'AWS' },
                archive: { tier: 'AWS (S3 Glacier Instant)', multiplier: 0.35, costFactor: 0.004, maxLatencyReduction: 0.60, accessCostFactor: 0.005, provider: 'AWS' },
            },
            Azure: {
                standard: { tier: 'Azure (Hot Blob Storage)', multiplier: 1.0, costFactor: 0.021, maxLatencyReduction: 0.1, accessCostFactor: 0.02, provider: 'Azure' },
                low_access: { tier: 'Azure (Cool Blob Storage)', multiplier: 0.68, costFactor: 0.012, maxLatencyReduction: 0.30, accessCostFactor: 0.011, provider: 'Azure' },
                archive: { tier: 'Azure (Archive Blob Storage)', multiplier: 0.30, costFactor: 0.002, maxLatencyReduction: 0.70, accessCostFactor: 0.004, provider: 'Azure' },
            },
            GCP: {
                standard: { tier: 'GCP (Standard Storage)', multiplier: 1.0, costFactor: 0.020, maxLatencyReduction: 0.1, accessCostFactor: 0.02, provider: 'GCP' },
                low_access: { tier: 'GCP (Nearline Storage)', multiplier: 0.60, costFactor: 0.01, maxLatencyReduction: 0.40, accessCostFactor: 0.01, provider: 'GCP' },
                archive: { tier: 'GCP (Coldline Storage)', multiplier: 0.40, costFactor: 0.007, maxLatencyReduction: 0.65, accessCostFactor: 0.007, provider: 'GCP' },
            }
        };

        function getOptionCost(dataSize, accessFrequency, option) {
            let optimizedStorageCost = option.costFactor * 1000 * dataSize;
            let optimizedAccessCost = option.accessCostFactor * 1000 * (accessFrequency / 50) * (dataSize / 100);
            let retrievalPenaltyFactor = 1 - option.multiplier;
            let retrievalFee = retrievalPenaltyFactor * 300 * (dataSize / 100);
            let egressFee = (accessFrequency / 100) * 500 * (dataSize / 100);
            let optimizedCost = optimizedStorageCost + optimizedAccessCost + retrievalFee + egressFee;

            const requiredMinTierMultiplier = (accessFrequency > 70) ? 0.9 : (accessFrequency > 40 ? 0.65 : 0.3);
            const isLatencyValid = option.multiplier >= requiredMinTierMultiplier;

            // Base cost per TB for the optimized tier (used for forecasting)
            const baseCostPerTB = (optimizedCost / dataSize) || 0.1;

            return {
                optimizedCost,
                optimizedStorageCost,
                optimizedAccessCost,
                retrievalFee,
                egressFee,
                isLatencyValid,
                baseCostPerTB
            };
        }

        // Core AI Decision Engine Simulation
        function calculateOptimization(dataSize, accessFrequency, budget, compliance, anomaly, forecastWindow) {
            const baselineCost = 25 * dataSize + (accessFrequency * 0.04 * dataSize);

            let bestOption = null;
            let lowestCost = Infinity;

            const cloudProviders = ['AWS', 'Azure', 'GCP'];
            const tiers = ['standard', 'low_access', 'archive'];

            let bestCostPerTB = 0;

            for (const provider of cloudProviders) {
                for (const tierName of tiers) {
                    const option = storageOptions[provider][tierName];
                    const { optimizedCost, isLatencyValid, baseCostPerTB, ...costComponents } = getOptionCost(dataSize, accessFrequency, option);

                    let finalOptimizedCost = optimizedCost;
                    if (compliance.toUpperCase().includes('HIPAA')) {
                        finalOptimizedCost *= 1.05;
                    }

                    if (finalOptimizedCost < lowestCost && isLatencyValid) {
                        lowestCost = finalOptimizedCost;
                        bestCostPerTB = baseCostPerTB;
                        bestOption = {
                            provider,
                            tierName,
                            ...option,
                            ...costComponents,
                            optimizedCost: finalOptimizedCost,
                            baselineCost: baselineCost,
                            baseCostPerTB: baseCostPerTB
                        };
                    }
                }
            }

            // --- 2. Constraint Checking ---
            if (dataSize > 4000 && accessFrequency > 500) {
                return { status: STATUS.PHYSICAL_VIOLATION, rationale: `Exceeds I/O capacity of any single cost-effective tier.`, solution: `Implement a federated storage strategy.`, minRequiredCost: 0 };
            }

            if (!bestOption) {
                 return { status: STATUS.LATENCY_VIOLATION, rationale: `High access frequency demands a Hot Tier, but no tier meets both speed and cost expectations.`, solution: `Increase the Max Monthly Budget or decrease Access Frequency.`, minRequiredCost: lowestCost };
            }

            const requiredMinTierMultiplier = (accessFrequency > 70) ? 0.9 : (accessFrequency > 40 ? 0.65 : 0.3);
            if (bestOption.multiplier < requiredMinTierMultiplier) {
                return { status: STATUS.LATENCY_VIOLATION, rationale: `The cheapest tier found (**${bestOption.tier}**) fails to meet the minimum required I/O performance for your high access frequency.`, solution: `Increase the Max Monthly Budget to afford a warmer tier.`, minRequiredCost: bestOption.optimizedCost };
            }

            if (bestOption.optimizedCost > budget) {
                return { status: STATUS.BUDGET_VIOLATION, rationale: `The calculated cost for the optimal technical solution (**${bestOption.tier}**) is **${formatCurrency(bestOption.optimizedCost)}**, which exceeds your budget.`, solution: `Increase the Max Monthly Budget to at least **${formatCurrency(bestOption.optimizedCost)}** or reduce the Data Volume/Access Frequency.`, minRequiredCost: bestOption.optimizedCost };
            }

            // --- 3. Anomaly Override ---
            let finalRecommendation = bestOption;
            let finalRationale = `The AI performed an exhaustive search and selected **${finalRecommendation.tier}** because it offered the lowest monthly cost (${formatCurrency(finalRecommendation.optimizedCost)}) while satisfying the latency requirements.`;
            let anomalyDetected = anomaly;

            if (anomaly && finalRecommendation.tierName === 'archive') {
                const provider = finalRecommendation.provider;
                finalRecommendation = storageOptions[provider].low_access;

                const newCostResult = getOptionCost(dataSize, accessFrequency, finalRecommendation);
                finalRecommendation = { ...finalRecommendation, ...newCostResult, optimizedCost: newCostResult.optimizedCost };

                if (compliance.toUpperCase().includes('HIPAA')) {
                     finalRecommendation.optimizedCost *= 1.05;
                }
                
                finalRecommendation.baseCostPerTB = (finalRecommendation.optimizedCost / dataSize) || 0.12;

                finalRationale = `ANOMALY OVERRIDE: Predicted access spike requires shifting from the cold tier to **${finalRecommendation.tier}** to prevent high egress/retrieval penalty costs.`;
            }

            let savings = ((baselineCost - finalRecommendation.optimizedCost) / baselineCost) * 100;
            
            // The cost used for the predicted graph is the base cost factor of the final recommended tier
            const predictedCostPerTB = finalRecommendation.baseCostPerTB;
            // The cost used for the actual graph (historical) is the baseline cost factor
            const actualCostPerTB = (baselineCost / dataSize) || 0.25;

            // --- 4. SUCCESS Case ---
            return {
                status: STATUS.SUCCESS,
                providerTier: finalRecommendation.tier,
                savings: Math.max(0, savings),
                latencyReduction: 'â‰ˆ' + (finalRecommendation.maxLatencyReduction * 100).toFixed(0) + '%',
                baselineCost: baselineCost,
                optimizedCost: finalRecommendation.optimizedCost,
                retrievalFee: finalRecommendation.retrievalFee,
                egressFee: finalRecommendation.egressFee,
                optimizedAccessCost: finalRecommendation.optimizedAccessCost,
                rationale: finalRationale,
                anomaly: anomalyDetected,
                budget: budget,
                dataSize: dataSize,
                forecastWindow: forecastWindow,
                actualCostPerTB,
                predictedCostPerTB,
            };
        }

        // --- DOM Manipulation Functions (Cost Breakdown Bar Chart) ---
        function updateCostBreakdown(baseline, optimized, egress, retrieval) {
            const chartContainer = document.getElementById('costBreakdownChart');
            chartContainer.innerHTML = '';
            const maxCost = Math.max(baseline, optimized) * 1.05 || 100;

            const data = [
                { title: 'Baseline Cost', value: baseline, id: 'original', color: getCssColor('--accent-color') }, // Use resolved color
                { title: 'Optimized Cost', value: optimized, id: 'optimized', color: getCssColor('--success-color') }, // Use resolved color
                { title: 'Egress Fees (Predicted)', value: egress, id: 'egress', color: getCssColor('--error-color') }, // Use resolved color
                { title: 'Retrieval Fees', value: retrieval, id: 'retrieval', color: getCssColor('--highlight-color') }, // Use resolved color
            ];
            
            // Ensure positive costs for visualization, use a small value if cost is 0
            const safeData = data.map(item => ({ ...item, value: item.value < 0.1 ? 0.1 : item.value }));

            safeData.forEach(item => {
                const heightPercent = Math.min(100, (item.value / maxCost) * 100);

                const barHtml = `
                    <div class="flex-1 max-w-[120px] bg-gray-700 rounded-t-md relative flex flex-col justify-end items-center transition-all duration-700" style="height: 100%;">
                        <div class="w-full transition-all duration-700 ease-out absolute bottom-0" style="height: ${heightPercent}%; background-color: ${item.color}; border-radius: 4px 4px 0 0; box-shadow: 0 0 8px ${item.color}44;"></div>
                        <span class="absolute top-[-25px] text-xs font-bold" style="color: ${item.color};">${formatCurrency(item.value)}</span>
                        <span class="absolute bottom-[-20px] text-[0.65rem] text-center text-gray-400">${item.title.split(' ')[0]}</span>
                    </div>
                `;
                chartContainer.insertAdjacentHTML('beforeend', barHtml);
            });
        }
        
        // Function to handle the mode switch (TB vs $)
        window.toggleGraphMode = function(mode) {
            if (usageChartInstance && currentChartData.labels.length > 0) {
                drawChart(mode);
            }
        };

        // Function to generate the data structure for the graph
        function generateForecastData(dataSize, forecastWindow, actualCostPerTB, predictedCostPerTB) {
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const historyLength = 12;

            const labels = [];
            
            // 1. Generate labels for history and forecast
            for (let i = historyLength; i > 0; i--) {
                const monthIndex = (new Date().getMonth() - i + 12) % 12;
                labels.push(months[monthIndex]);
            }
            const currentMonthIndex = new Date().getMonth();
            for (let i = 0; i < forecastWindow; i++) {
                 const monthIndex = (currentMonthIndex + i) % 12;
                 labels.push(months[monthIndex] + (i >= 12 ? ' +' + Math.floor((i + 1) / 12) : ''));
            }

            // 2. Generate actual historical usage data (12 points)
            let currentUsage = dataSize - (dataSize * 0.2); // Start 20% lower than current input
            const actualUsage = [];

            for (let i = 0; i < historyLength; i++) {
                currentUsage += (Math.random() * (dataSize * 0.008) + (dataSize * 0.002)); 
                actualUsage.push(Math.round(currentUsage));
            }

            // 3. Generate predicted future usage data
            let predictedUsage = actualUsage[historyLength - 1];
            const predictedUsageData = Array(historyLength).fill(null);
            predictedUsageData[historyLength - 1] = predictedUsage;

            for (let i = 0; i < forecastWindow; i++) {
                predictedUsage += (dataSize * 0.01 + Math.random() * (dataSize * 0.005));
                predictedUsageData.push(Math.round(predictedUsage));
            }
            
            // 4. Combine Actual/Predicted usage into one array for the 'Actual' line (with projection segment)
            const fullActualUsage = [...actualUsage, ...predictedUsageData.slice(historyLength)];

            // 5. Generate Cost Data based on Usage Data
            const actualCost = fullActualUsage.map(tb => Math.round(tb * actualCostPerTB * 1000)); // Cost is higher for historical baseline tier
            const predictedCost = predictedUsageData.map(tb => tb === null ? null : Math.round(tb * predictedCostPerTB * 1000)); // Cost is lower for optimized tier

            currentChartData = {
                labels: labels,
                usage: { actual: fullActualUsage, predicted: predictedUsageData },
                cost: { actual: actualCost, predicted: predictedCost },
                dataSize: dataSize,
                forecastWindow: forecastWindow
            };
        }

        /**
         * Initializes or updates the Chart.js graph with simulated Actual and Predicted Data.
         */
        function drawChart(mode = 'usage') {
            const ctx = document.getElementById('usageChart').getContext('2d');
            
            if (usageChartInstance) {
                usageChartInstance.destroy();
            }

            const isUsageMode = mode === 'usage';
            const dataSet = isUsageMode ? currentChartData.usage : currentChartData.cost;
            const unit = isUsageMode ? 'TB' : '$';
            const label = isUsageMode ? 'Storage Usage' : 'Projected Cost';
            const tooltipFormat = (value) => isUsageMode ? `${value} TB` : formatCurrency(value);

            // --- FIX: Resolve CSS colors before passing them to Canvas/Chart.js ---
            const actualColor = getCssColor('--chart-actual-color');
            const predictedColor = getCssColor('--chart-predicted-color');

            // Create the gradients using the resolved hex colors
            const actualGradient = createGradient(ctx, actualColor);
            const predictedGradient = createGradient(ctx, predictedColor);


            usageChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: currentChartData.labels,
                    datasets: [
                        {
                            label: `Actual/Baseline ${label}`,
                            data: dataSet.actual,
                            // High contrast color
                            borderColor: actualColor, // Use resolved color
                            backgroundColor: actualGradient,
                            borderWidth: 3,
                            fill: 'origin', // Fill area under the line
                            tension: 0.4,
                            pointRadius: 4,
                            pointHoverRadius: 6,
                            pointBackgroundColor: actualColor, // Use resolved color
                            pointBorderColor: getCssColor('--bg-color'), // Use resolved color
                            order: 1 // Draw actual line first (in back)
                        },
                        {
                            label: `AI Optimized ${label}`,
                            data: dataSet.predicted,
                            // High contrast color
                            borderColor: predictedColor, // Use resolved color
                            backgroundColor: predictedGradient,
                            borderWidth: 3,
                            fill: 'origin',
                            tension: 0.4,
                            pointRadius: 4,
                            pointHoverRadius: 6,
                            pointBackgroundColor: predictedColor, // Use resolved color
                            pointBorderColor: getCssColor('--bg-color'), // Use resolved color
                            // Dotted line for prediction segment
                            borderDash: [8, 4], 
                            order: 0 // Draw predicted line second (in front)
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: (items) => `Month: ${items[0].label}`,
                                label: (context) => {
                                    const value = context.parsed.y;
                                    const labelText = context.dataset.label;
                                    return `${labelText}: ${tooltipFormat(value)}`;
                                }
                            },
                            bodyFont: { family: 'Roboto Mono', size: 14, weight: '700' },
                            titleFont: { family: 'Orbitron', size: 16 },
                            backgroundColor: 'rgba(30, 30, 44, 0.95)', // Dark card color
                            borderColor: getCssColor('--accent-color'), // Use resolved color
                            borderWidth: 1,
                            cornerRadius: 6,
                            caretSize: 8,
                            padding: 12,
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Time (Months)', color: getCssColor('--highlight-color'), font: { family: 'Orbitron' } }, // Use resolved color
                            grid: { color: '#2a2a38' },
                            ticks: { color: getCssColor('--text-color') } // Use resolved color
                        },
                        y: {
                            title: { display: true, text: `${label} (${unit})`, color: getCssColor('--highlight-color'), font: { family: 'Orbitron' } }, // Use resolved color
                            beginAtZero: false,
                            grid: { color: '#2a2a38' },
                            ticks: {
                                color: getCssColor('--text-color'), // Use resolved color
                                callback: function(value, index, ticks) {
                                    return isUsageMode ? `${value} TB` : formatCurrency(value);
                                }
                            }
                        }
                    }
                }
            });
        }


        // --- Event Listeners and Main Logic ---

        document.getElementById('optimizerForm').addEventListener('submit', function(e) {
            e.preventDefault();

            const dataSize = parseFloat(document.getElementById('dataSize').value);
            const accessFrequency = parseFloat(document.getElementById('accessFrequency').value);
            const compliance = document.getElementById('compliance').value;
            const budget = parseFloat(document.getElementById('budget').value);
            const forecastWindow = parseInt(document.getElementById('forecastWindow').value);
            const injectAnomaly = document.getElementById('injectAnomaly').checked;

            const results = calculateOptimization(
                dataSize,
                accessFrequency,
                budget,
                compliance,
                injectAnomaly,
                forecastWindow
            );

            // DOM elements
            const violationAlert = document.getElementById('violationAlert');
            const anomalyAlert = document.getElementById('anomalyAlert');
            const provisionButton = document.getElementById('provisionButton');
            const resultProvider = document.getElementById('resultProvider');
            const resultSavings = document.getElementById('resultSavings');
            const resultLatency = document.getElementById('resultLatency');
            const resultExplanation = document.getElementById('resultExplanation');


            // Reset UI state
            violationAlert.classList.add('hidden');
            anomalyAlert.classList.add('hidden');
            provisionButton.disabled = false;
            provisionButton.textContent = "Simulate Provisioning via Terraform (IaC) â†’";
            resultProvider.style.color = getCssColor('--success-color');
            resultSavings.style.color = getCssColor('--success-color');
            resultLatency.style.color = getCssColor('--success-color');
            
            // Set alert months text
            document.getElementById('alert-months').textContent = forecastWindow;


            if (results.status !== STATUS.SUCCESS) {
                // --- VIOLATION HANDLING ---
                violationAlert.classList.remove('hidden');
                document.getElementById('violationMessage').innerHTML = `&#10060; **CRITICAL CONSTRAINT VIOLATION: ${results.status.replace('_', ' ')}**`;
                document.getElementById('violationSolution').innerHTML = `**Reason:** ${results.rationale}<br><br>**Solution:** ${results.solution}`;

                resultProvider.textContent = 'FAILURE';
                resultSavings.textContent = 'N/A';
                resultLatency.textContent = 'N/A';
                resultProvider.style.color = getCssColor('--error-color');
                resultSavings.style.color = getCssColor('--error-color');
                resultLatency.style.color = getCssColor('--error-color');

                provisionButton.disabled = true;
                provisionButton.textContent = "Provisioning Disabled (Violation)";

                updateCostBreakdown(results.minRequiredCost || 0, 0, 0, 0);
                
                // Initialize forecast data even on failure (using baseline cost per TB)
                generateForecastData(dataSize, forecastWindow, results.minRequiredCost > 0 ? (results.minRequiredCost / dataSize) : 0.25, 0.25);
                drawChart(document.querySelector('input[name="graphMode"]:checked').value);
                
                resultExplanation.innerHTML = `The optimization loop terminated due to a **${results.status.replace('_', ' ')}** error. Please review the violation message above.`;

            } else {
                // --- SUCCESS HANDLING ---
                resultProvider.textContent = results.providerTier;
                resultSavings.textContent = `${results.savings.toFixed(1)}%`;
                resultLatency.textContent = results.latencyReduction;

                if (results.anomaly) {
                    anomalyAlert.classList.remove('hidden');
                }

                resultExplanation.innerHTML = `
                    The AI performed multi-objective optimization over a **${forecastWindow}-month** horizon. It found the optimal balance between cost, latency,
                    and the **${compliance.toUpperCase()}** compliance requirements based on the predicted **${accessFrequency}M** monthly reads.
                    **Decision Rationale:** ${results.rationale}
                `;

                updateCostBreakdown(
                    results.baselineCost,
                    results.optimizedCost,
                    results.egressFee,
                    results.retrievalFee
                );

                document.getElementById('provisionButton').onclick = function() {
                    const modal = document.getElementById('provisionModal');
                    document.getElementById('modal-text').textContent =
                        `IaC Automation successful. ${dataSize}TB of storage provisioned to ${results.providerTier} with a ${results.savings.toFixed(1)}% projected saving.`;
                    modal.style.display = 'flex';
                };

                // Generate and draw the new interactive forecast graph
                generateForecastData(dataSize, forecastWindow, results.actualCostPerTB, results.predictedCostPerTB);
                drawChart(document.querySelector('input[name="graphMode"]:checked').value);
            }

            document.getElementById('output').scrollIntoView({ behavior: 'smooth' });
        });

        // --- Dependency Modal Logic (Kept separate for clarity) ---
        const dependencyModal = document.getElementById('dependencyModal');
        const openDependencyModalBtn = document.getElementById('openDependencyModalBtn');
        const closeDependencyModalBtn = document.getElementById('closeDependencyModalBtn');

        window.openDependencyModal = function() {
            dependencyModal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
        }

        window.closeDependencyModal = function() {
            dependencyModal.classList.add('hidden');
            document.body.style.overflow = '';
        }

        openDependencyModalBtn.addEventListener('click', openDependencyModal);
        closeDependencyModalBtn.addEventListener('click', closeDependencyModal);

        dependencyModal.addEventListener('click', (e) => {
            if (e.target === dependencyModal) {
                closeDependencyModal();
            }
        });
        
        // Initial setup for the graph and cost breakdown (runs when the window is fully loaded)
        window.onload = function() {
            const initialDataSize = parseFloat(document.getElementById('dataSize').value);
            const initialForecast = parseInt(document.getElementById('forecastWindow').value);
            
            // Initial dummy forecast data
            generateForecastData(initialDataSize, initialForecast, 0.25, 0.15); 
            drawChart('usage');
            
            // Initial dummy cost breakdown
            updateCostBreakdown(3000, 2000, 200, 100);
        };
    </script>
</body>
</html>
